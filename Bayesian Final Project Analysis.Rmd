---
title: "Bayesian Final Proj Analysis"
output: html_document
date: "2024-05-02"
---
```{r}

#import the data and subset it to get the relevant features
X = read.csv("X_centered.csv")
y = read.csv("weather_prediction_bbq_labels.csv")
inds_to_consider_X = c(5, 8, 10, 14, 17, 19, 24, 27, 29, 35, 37, 39, 45, 48, 50, 54, 57, 59, 64, 67, 69, 74, 77, 79, 85, 88, 90, 99, 102, 103, 109, 112, 114, 120, 123, 125, 129, 132, 133, 145, 147, 149, 160, 163, 164)
inds_to_consider_y = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 18)
X_new = X[, inds_to_consider_X]
y_2 = y[, inds_to_consider_y]
y_3 = as.data.frame(lapply(y_2, function(x) toupper(x)))
y_new = as.data.frame(lapply(y_3, function(x) as.logical(tolower(x))))
```


```{r}
y_new
```



```{r}
X_new
```

```{r}
#get the beta.j for each country
track = 1
beta_list = list()
country_name_list = c("BASEL", "BUDAPEST", "DE_BILT", "DRESDEN", "DUSSELDORF", "HEATHROW", "KASSEL", "LJUBLJANA", "MAASTRICHT", "MONTELIMAR", "MUENCHEN", "OSLO", "PERPIGNAN", "SONNBLICK", "TOURS")
for (i in 1:45) {
  if ((i - 1) %% 3 == 0) {
    X_to_consider = X_new[, i:(i+2)]
    y_temp = y_new[, track]
    y_to_consider = as.numeric(y_temp)
    country_name = country_name_list[track]
    model = glm(y_to_consider~., data=X_to_consider, family="binomial", maxit=10000)
    beta_list[[country_name]] <- coef(model)
    track = track + 1
  }
}

```
```{r}
print(beta_list[[1]])
```


```{r}
#get the theta list
p = 4
J = 15
theta_list = c()
for (i in 1:p){
  sum = 0
  for (j in 1:J){
    sum = sum + beta_list[[j]][[i]]
  }
  avg = sum/J
  theta_list = c(theta_list, avg)
}
print(theta_list)
```

```{r}
#get the variance matrix
sum_var = matrix(0, nrow=p, ncol=p)
for (j in 1:J){
  beta_diff = beta_list[[j]] - theta_list
  beta_prod = (beta_diff) %*% t(beta_diff)
  sum_var = sum_var + beta_prod
}
sigma = sum_var/(J-p)
print(sigma)
```

```{r}
#1: Do Logistic Regression on BASEL

X_BASEL = X_new[, 1:3]
y_BASEL = y_new[, 1]
glm_BASEL = glm(y_BASEL~., data=X_BASEL, family="binomial", maxit=1000)
coefs_BASEL = glm_BASEL$coefficients
coefs_BASEL
```

```{r}
n <- length(y)
#pmn.alpha.beta <- rep(0,p) # prior mean
pmn.alpha.beta <- as.vector(coefs_BASEL) # prior mean
psd.alpha.beta <- rep(10,p) # prior SD=10/var=100
```

```{r}
prior_alpha_beta <- function(alpha.beta) {
  return(dnorm(alpha.beta, as.vector(coefs_BASEL), rep(10, p), log=T))  
}

## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E <- matrix(rnorm(n*length(mu)),n,length(mu))
t( t(E%*%chol(Sigma)) +c(mu))
}

log_likelihood <- function(y, alpha.beta, x) {
  alpha.beta_2_4 = matrix(rep(alpha.beta[2:p], each = nrow(x)), nrow = nrow(x), byrow = FALSE)
  p_y_given_theta = y*(alpha.beta[1]+alpha.beta_2_4*x)-log(1+exp(alpha.beta[1]+alpha.beta_2_4*x))
  return(p_y_given_theta)
}

proposal_alpha_beta <- function(alpha.beta) {
  return(t(rmvnorm(1, alpha.beta, var.prop))) 
}
```

```{r}
alpha.beta.star = proposal_alpha_beta(as.vector(coefs_BASEL))
print(as.vector(alpha.beta.star[1:p]))
print(as.matrix(X_BASEL))
test = log_likelihood(y_BASEL, alpha.beta.star, X_BASEL)
print(test)
```

```{r}
alpha <- c(1, 2, 3)

# Define the 100x3 matrix beta
beta <- matrix(1:300, nrow = 100, ncol = 3)

alpha_repeated <- matrix(rep(alpha, each = nrow(beta)), nrow = nrow(beta), byrow = FALSE)

# Perform element-wise multiplication
result <- alpha_repeated * beta
result
```



```{r}
ACR<-NULL
ACF<-NULL

delta2 <- 2e-5 #this delta gave us about 18% of the acceptance rate
#variance-covariance matrix of a proposal distribution

S <- 10
R = 1
ac <- 0
alpha.beta <- pmn.alpha.beta #initializing the markov chain
ALPHA.BETA <- matrix(0,nrow=S/R,ncol=p)
var.prop <- diag(delta2, nrow = p, ncol = p)
set.seed(1)

## MCMC
for(s in 1:S) {
  
#propose a new alpha.beta
alpha.beta.star <- proposal_alpha_beta(alpha.beta)

logr <- sum(log_likelihood(y_BASEL, alpha.beta.star, X_BASEL)) + sum(prior_alpha_beta(alpha.beta.star)) 
- sum(log_likelihood(y_BASEL, alpha.beta, X_BASEL)) - sum(prior_alpha_beta(alpha.beta)) 

print(logr)
if( log(runif(1)) < logr ) { 
  alpha.beta <- alpha.beta.star
  ac <- ac+1 
}

if (s %% R == 0) { 
  ALPHA.BETA[s/R,] <- alpha.beta}
}
ACR <- c(ACR,ac/S)
ACF <- c(ACF,acf(ALPHA.BETA[,1],plot=FALSE)$acf[2])
```

```{r}
ACR
```

