---
title: "Bayesian Final Proj Analysis"
output: html_document
date: "2024-05-02"
---
```{r}

#import the data and subset it to get the relevant features
X = read.csv("X_centered.csv")
y = read.csv("weather_prediction_bbq_labels.csv")
inds_to_consider_X = c(5, 8, 10, 14, 17, 19, 24, 27, 29, 35, 37, 39, 45, 48, 50, 54, 57, 59, 64, 67, 69, 74, 77, 79, 85, 88, 90, 99, 102, 103, 109, 112, 114, 120, 123, 125, 129, 132, 133, 145, 147, 149, 160, 163, 164)
inds_to_consider_y = c(2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 18)
X_new = X[, inds_to_consider_X]
y_2 = y[, inds_to_consider_y]
y_3 = as.data.frame(lapply(y_2, function(x) toupper(x)))
y_4 = as.data.frame(lapply(y_3, function(x) as.logical(tolower(x))))
y_new <- as.data.frame(lapply(y_4, function(x) ifelse(x, 1, 0)))
```

```{r}
X_new
```



```{r}
y_new
```

```{r}
y_4
```


```{r}
X_new
```

```{r}
#get the beta.j for each country
track = 1
beta_list = list()
country_name_list = c("BASEL", "BUDAPEST", "DE_BILT", "DRESDEN", "DUSSELDORF", "HEATHROW", "KASSEL", "LJUBLJANA", "MAASTRICHT", "MONTELIMAR", "MUENCHEN", "OSLO", "PERPIGNAN", "SONNBLICK", "TOURS")
for (i in 1:45) {
  if ((i - 1) %% 3 == 0) {
    X_to_consider = X_new[, i:(i+2)]
    y_temp = y_new[, track]
    y_to_consider = as.numeric(y_temp)
    country_name = country_name_list[track]
    model = glm(y_to_consider~., data=X_to_consider, family="binomial", maxit=10000)
    beta_list[[country_name]] <- coef(model)
    track = track + 1
  }
}
print(beta_list)
```
```{r}
beta_df = do.call(rbind, beta_list)
row.names(beta_df) = names(beta_list)
colnames(beta_df) = c("Intercept", "Humidity", "Precipitation", "Mean Temperature")
beta_df
```


```{r}
#get the theta list
p = 4
J = 15
#theta_list = c()
#for (i in 1:p){
#  sum = 0
#  for (j in 1:J){
#    sum = sum + beta_list[[j]][[i]]
#  }
#  avg = sum/J
#  theta_list = c(theta_list, avg)
#}

theta_list = apply(beta_df, 2, mean)
print(theta_list)
```



```{r}
#get the variance matrix
sum_var = matrix(0, nrow=p, ncol=p)
for (j in 1:J){
  beta_diff = beta_list[[j]] - theta_list
  beta_prod = (beta_diff) %*% t(beta_diff)
  sum_var = sum_var + beta_prod
}
sigma = sum_var/(J-p)
print(sigma)
```

```{r}
#1: Do Logistic Regression on BASEL
p=4
X_BASEL = X_new[, 1:3]
y_BASEL = y_new[, 1]
glm_BASEL = glm(y_BASEL~., data=X_BASEL, family="binomial", maxit=1000)
#glm_BASEL = glm(y_BASEL~X_BASEL, family="binomial", maxit=1000)
coefs_BASEL = glm_BASEL$coefficients
coefs_BASEL
```

```{r}
n <- length(y)
#pmn.alpha.beta <- rep(0,p) # prior mean
pmn.alpha.beta <- rep(0,p) # prior mean
psd.alpha.beta <- rep(10,p) # prior SD=10/var=100
```

```{r}
prior_alpha_beta <- function(alpha.beta) {
  return(dnorm(alpha.beta, pmn.alpha.beta, psd.alpha.beta, log=T))  
}

## rmvnorm function for proposals
rmvnorm<-function(n,mu,Sigma)
{ # samples from the multivariate normal distribution
E <- matrix(rnorm(n*length(mu)),n,length(mu))
t( t(E%*%chol(Sigma)) +c(mu))
}

proposal_alpha_beta <- function(alpha.beta) {
  return(t(rmvnorm(1, alpha.beta, var.prop))) 
}
```

```{r}
ACR<-NULL
ACF<-NULL

delta2 <- 2e-5 #this delta gave us about 18% of the acceptance rate
#variance-covariance matrix of a proposal distribution

S <- 1000
R = 10
ac <- 0
alpha.beta <- rep(0, p) #initializing the markov chain
#alpha.beta = c(-30, -7, -30, 1)
ALPHA.BETA <- matrix(0,nrow=S/R,ncol=p)
ALPHA.BETA[1,]=alpha.beta
var.prop <- diag(delta2, nrow = p, ncol = p)
set.seed(1)

y=y_BASEL
x=X_BASEL

## MCMC
for(s in 2:S) {
  
#propose a new alpha.beta
alpha.beta.star <- proposal_alpha_beta(alpha.beta)

#logr <- sum(log_likelihood(y_BASEL, alpha.beta.star, X_BASEL)) + sum(prior_alpha_beta(alpha.beta.star)) 
#- sum(log_likelihood(y_BASEL, alpha.beta, X_BASEL)) - sum(prior_alpha_beta(alpha.beta)) 

logr = sum(y*(alpha.beta.star[1]+alpha.beta.star[2:p]*x)) -
sum(log(1+exp(alpha.beta.star[1]+alpha.beta.star[2:p]*x))) -
sum(y*(alpha.beta[1]+alpha.beta[2:p]*x)) +
sum(log(1+exp(alpha.beta[1]+alpha.beta[2:p]*x))) +
sum(dnorm(alpha.beta.star,pmn.alpha.beta,psd.alpha.beta,log=T)) -
sum(dnorm(alpha.beta,pmn.alpha.beta,psd.alpha.beta,log=T))

if( log(runif(1)) < logr ) { 
  alpha.beta <- alpha.beta.star
  ac <- ac+1 
}

if (s %% R == 0) { 
  print(s)
  ALPHA.BETA[s/R,] <- alpha.beta}
}
ACR_BASEL <- c(ACR,ac/S)
ACF_BASEL <- c(ACF,acf(ALPHA.BETA[,1],plot=FALSE)$acf[2])
```
```{r}
ACR_BASEL
```


```{r}
library(coda)
print("Effective sample size for alphaˆ(s) and betaˆ(s)")
apply(ALPHA.BETA.BASEL,2,effectiveSize)
```

```{r}
print("Prior means and variances of alpha, beta")
pmn.alpha.beta
```

```{r}
psd.alpha.beta**2
```


```{r}
print("Posterior mean and variances of alpha, beta")
apply(ALPHA.BETA.BASEL,2,mean)
```

```{r}
apply(ALPHA.BETA.BASEL,2,var)
```

```{r}
par(mfrow = c(1, 4)) # Set up the layout for side-by-side plots
# Plot for the first row (ALPHA)
density_alpha <- density(ALPHA.BETA.BASEL[,1])
plot(density_alpha, col = "blue", main = "BASEL ALPHA",xlim = c(-5,5))
lines(density(rnorm(S, 0, 10)), col = "red") # Add a reference line
legend("topright", legend = c("Posterior", "Prior"), col = c("blue", "red"), lty = 1)

# Plot for the second row (BETA 1)
density_beta_1 <- density(ALPHA.BETA.BASEL[,2])
plot(density_beta_1, col = "blue", main = "BASEL BETA Humidity",xlim = c(-5,5))
lines(density(rnorm(S, 0, 10)), col = "red") # Add a reference line
legend("topright", legend = c("Posterior", "Prior"), col = c("blue", "red"), lty = 1)

# Plot for the third row (BETA 2)
density_beta_2 <- density(ALPHA.BETA.BASEL[,3])
plot(density_beta_2, col = "blue", main = "BASEL BETA Precipitation",xlim = c(-5,5))
lines(density(rnorm(S, 0, 10)), col = "red") # Add a reference line
legend("topright", legend = c("Posterior", "Prior"), col = c("blue", "red"), lty = 1)

# Plot for the fourth row (BETA 3)
density_beta_3 <- density(ALPHA.BETA.BASEL[,4])
plot(density_beta_3, col = "blue", main = "BASEL BETA Mean Temperature",xlim = c(-5,5))
lines(density(rnorm(S, 0, 10)), col = "red") # Add a reference line
legend("topright", legend = c("Posterior", "Prior"), col = c("blue", "red"), lty = 1)
```

```{r}
#ACF Plots
par(mfrow = c(1, 4)) # Set up the layout for side-by-side plots
acf(ALPHA.BETA[,1])
acf(ALPHA.BETA[,2])
acf(ALPHA.BETA[,3])
acf(ALPHA.BETA[,4])
```

```{r}
#Do Regular Logistic Regression on Budapest
#1: Do Logistic Regression on BASEL
p=4
X_BUDAPEST = X_new[, 4:6]
y_BUDAPEST = y_new[, 2]
glm_BUDAPEST = glm(y_BUDAPEST~., data=X_BUDAPEST, family="binomial", maxit=1000)
coefs_BUDAPEST = glm_BUDAPEST$coefficients
coefs_BUDAPEST
```



```{r}
#2: Do hierarchical logistic regression on all countries

m = J = 15
p = 4

mu0 = apply(beta_df, 2, mean)
S0 = sigma
eta0 = p+2
iL0 = solve(S0)
iSigma = solve(S0)
delta2 <- 2e-5
var.prop <- diag(delta2, nrow = p, ncol = p)
```

```{r}
#MCMC
library(mvtnorm)
library(MCMCpack)
library(coda)

THETA.post = NULL
SIGMA.post = NULL
set.seed(1)
for (s in 1:50)
{
  
  #update theta
  Lm = solve(iL0 + m*iSigma)
  mum = Lm%*%( iL0%*%mu0 + iSigma%*%apply(beta_df,2,sum) )
  theta<-t(rmvnorm(1,mum,Lm))
  
  #update sigma
  mtheta<-matrix(theta,m,p,byrow=TRUE)
  iSigma<-rwish(eta0+m, solve( S0+t(beta_df-mtheta)%*%(beta_df-mtheta)) )
  
  #update beta
  
}
```


